'''

Search in rorated sorted array

You are given an array of length n which was originally sorted in ascending order. It has now been rotated between 1 and n times. For example, the array nums = [1,2,3,4,5,6] might become:

[3,4,5,6,1,2] if it was rotated 4 times.
[1,2,3,4,5,6] if it was rotated 6 times.
Given the rotated sorted array nums and an integer target, return the index of target within nums, or -1 if it is not present.

You may assume all elements in the sorted rotated array nums are unique,

A solution that runs in O(n) time is trivial, can you write an algorithm that runs in O(log n) time?

Brute Force:
Search through each halfs of the index and keep splitting it untl you get two each.
If target is found in any of the splits, return the index plus the half of the array it split.
If not, return -1 unless something is found.

Optimized:
Check if the first half is sorted. If it is, we need to check if the target is greater than the first half and less than
the middle. If it is greater than, it will splice the first half and repeat. If it is less than, it will splice
the second half. If the first half is not properly sorted, then the second half will most likely be. We then 
check if the target is greater than the middle, if not we splice from the first half. Eventually, it will splice
until something is found or when the array is empty. If empty, return -1. otherwise return index plus the middle
index.

Average time complexity is O(log n), worse case O(n log n)

'''



def search(nums: List[int], target: int) -> int:
        if not nums:
            return -1
            
        mid = len(nums)//2
        if nums[mid] == target:
            return mid
    
        #First half is sorted 
        if nums[0] < nums[mid]:
            if nums[0] <= target < nums[mid]:
                    
                index = search(nums[:mid],target)
                if index != -1:
                    return index
            else:
                index = search(nums[mid:], target)
                if index != -1:
                    return index + mid
        
        #Second half is sorted
        else:
            if nums[mid] < target <= nums[-1]:

                index = search(nums[mid:], target)
                if index != -1:
                    return index + mid
            
            else:
                index = search(nums[:mid], target)
                if index != -1:
                    return index

        return -1

# def search(nums: List[int], target: int) -> int:
#         if len(nums) == 1:
#             if nums[0] == target:
#                 return 0
#             else:
#                 return -1

#         if len(nums) == 2:
#             if nums[0] == target:
#                 return 0
#             if nums[1] == target:
#                 return 1
            
#         if len(nums)>2:
            
#             mid = len(nums)//2
#             if nums[mid] == target:
#                 return mid

#             left_index = search(nums[mid:],target)
#             if left_index != -1:
#                 return left_index + mid
            
#             right_index = search(nums[:mid + 1],target)
#             if right_index != -1:
#                 return right_index
#         return -1
            
nums = [1]
target = 7

print(search(nums, target))